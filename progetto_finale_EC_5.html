<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"></script>
	
	<style type="text/css">

		.slidecontainer {
		  width: 100%;
		}

		.slider {
		  	-webkit-appearance: none;
			width: 200px;
			height: 10px;
			border-radius: 5px;
			background: #d3d3d3;
			outline: none;
			opacity: 0.7;
			-webkit-transition: .2s;
			transition: opacity .2s;
			margin-left: 10%;
			margin-top: 8%;
		}

		.volume_tag{
			width: 53px;
			margin-left: 55%;
			margin-top: -1px;
		}

		.slidercontainer{
			display: inline-flex;
			height: 20px;
		}

		.slider:hover {
		  	opacity: 1;
		}

		.slider::-webkit-slider-thumb {
		  	-webkit-appearance: none;
		  	appearance: none;
		  	width: 20px;
			height: 20px;
			border-radius: 50%;
			background: #4CAF50;
			cursor: pointer;
		}

		.slider::-moz-range-thumb {
		  	width: 20px;
		 	height: 20px;
		  	border-radius: 50%;
		  	background: #4CAF50;
		  	cursor: pointer;
		}
	
		.canvas_block{
			position: relative;
			border:2px solid black;
			/*width:80%;
			height:30%;*/
			width: 600px;
			height: 200px;
			background-color: #FFFAF0;
		}

		#canvas_container{
			position:relative;
			margin-left:28%;
			margin-top: 1%;
		}

		p{
			text-align: center;
			font-family: serif;
			font-style: italic;
			font-size: 90%;
			margin-top: 10px;

		}

		body{
			background-color:#FF8C00;
			/*background-repeat: no-repeat;*/
		} 

		.container_all{
			margin-top: 1%;
		}

		.container{
			width: 44%;
			height: 120px;
			border: 1px solid black;
			margin-top: 1%;
		}

		#container_0{
			margin-right: 53%;
		}

		#container_1{
			margin-left: 53%;
			margin-top: -9%;
		}

		#container_2{
			margin-right: 53%;
		}

		#container_3{
			margin-left: 53%;
			margin-top: -9%;
		}

		#container_4{
			margin-right: 53%;
		}

		#container_5{
			margin-left: 53%;
			margin-top: -9%;
		}

		h6{
			font-family: serif;
			text-align: justify;
			text-align: center;
			margin-top: 1.5%;
			font-style: italic;
			font-weight: 400;
		}

		.span{
			margin-top: -2%;
		}

		.inputs{
			margin-left: 40%;
		}

		.input_values{
			width: 53px;
			cursor:pointer;
			outline:none;
			text-align: center;
			font-family: serif;
		}

		h2{
			position:relative;
			text-align:center;
			font-family: serif;
			font-size: 160%;
			font-weight: bold;
		}

		#rec_button{
			margin-left: 35%;
			margin-top: -1%;
		}

		#play_button{
			margin-left: 45%;
		}

		#harm_button{
			margin-left: 32%;
		}

		#play_all{
			margin-left: 37%;
		}

		#second_ctp{
			margin-left: 32%;
		}

		#canvas_tag{
			text-align: justify;
			margin-top: -1%;
		}

		.clicked_button{
			background-color: #292b9c;
		}

	</style>
</head>
<body>
	<div class="container_all">
		<h2>Harmonizer</h2>
		<div id="container_0" class = "container">
			<h6>Chooose the number of the Channel containing the melody and the chords of the MIDI file:</h6>
			<div class="span">
				<span class="choose" id="choose_melody">Melody</span>
				<span class="choose chord_class">Chords</span>
			</div>
			<div class="inputs">
				<input type="text" id="melody_input" value= "" class="input_values">
				<input type="text" id="chord_input" value= "" class="input_values chord_class">
			</div>
		</div>

			<!--<input type="submit" id="mySubmit" value="Confirm" class="btn btn-success">-->
		<div id="container_1" class="container">
			<h6>Click the button below to start aquiring data:</h6>
			<p>Click again when you finish recording.</p>
			<button id="rec_button" class="btn btn-success">Record input data</button>
		</div>

		<div id="container_2" class="container">
			<h6>Click this play-button to play the input sequence:</h6>
			<button id="play_button" class="btn btn-success">Play</button>
			<div class="slidercontainer" id="slider2">
				<!--<button id="play_button" class="btn btn-success">Play</button>-->
				<!--<div class="span_container">-->
					<p class="volume_tag">Volume: <span id="span1" class="span"></span></p>
					<input type="range" name="volume" min="0.0" max="1.0" step="0.01" value="0.5" id="volumeControl_1" class="slider">
				<!--</div>-->
			</div>
		</div>

		<div id="container_3" class="container">
			<h6>Click the button below to listen to the harmonized version:</h6>
			<button id="harm_button" class="btn btn-success">1st counterpoint version</button>
			<div class="slidercontainer" id="slider3">
				<!--<div class="span_container">-->
					<p class="volume_tag">Volume: <span id="span2"></span></p>
					<input type="range" name="volume" min="0.0" max="1.0" step="0.01" value="0.5" id="volumeControl_2" class="slider">
				<!--</div>-->
			</div>
		</div>

		<div id="container_4" class="container">
			<h6>Click here to listen to the harmonized version of the input piece:</h6>
			<button id="play_all" class="btn btn-success">Complete version</button>
			<div class="slidercontainer" id="slider4">
				<!--<div class="span_container">-->
					<p class="volume_tag">Volume: <span id="span3"></span></p>
					<input type="range" name="volume" min="0.0" max="1.0" step="0.01" value="0.5" id="volumeControl_3" class="slider">
				<!--</div>-->
			</div>
		</div>

		<div id="container_5" class="container">
			<h6>Click here to listen to the second counterpoint version of the input piece:</h6>
			<button id="second_ctp" class="btn btn-success">2nd counterpoint version</button>
			<div class="slidercontainer" id="slider5">
				<!--<div class="span_container">-->
					<p class="volume_tag">Volume: <span id="span4"></span></p>
					<input type="range" name="volume" min="0.0" max="1.0" step="0.01" value="0.5" id="volumeControl_4" class="slider">
				<!--</div>-->
			</div>
		</div>

		<div id="canvas_container">
			<canvas class="canvas_block" id="time_canvas"></canvas>
			<p id="canvas_tag">Visualization of the played signal in time domain</p>
		</div>			
	</div>
	</div>

	<script type="text/javascript">
		
		var i = 0;
		var note_array = new Array;
		var chord_array = new Array;
		var j = 0; 
		var send = false;
		var counter; //ex francoispachet
		var counter_note;
		var counter_second;

		var note_duration = new Array;
		var note_time = new Array;
		var noteOn = new Array;	
		var chord_duration = new Array;
		var chord_time = new Array;
		var chordOn = new Array;
		var last_note_index = 0; //ex davidelogiri
		var last_chord_index = 0; //ex stevenwilson
		var num_note = new Array;
		var min_midi_freq = 21;
		var min_keyb_freq = 27.5;

		var melody_channel;
		var chord_channel;

		var harmony;


		//record button functionalities:
		//request MIDI Access (on MIDI success)
		//compute the chords duration array the first species ctp notes
		//keep track of some important indexes

		document.querySelectorAll("#rec_button").forEach(toggleRecord);
		
		function toggleRecord(item){
			item.onclick = record;
		}
		
		function record(){
			this.classList.toggle("clicked_button");
			melody_channel = document.getElementById("melody_input").value; //we store the value of the channel for the melody
			chord_channel = document.getElementById("chord_input").value; //we store the value of the channel for the chords
			send = !send;
			console.log(send + " record");
			if (send){
				navigator.requestMIDIAccess().then(onMIDISuccess);
				counter = s_m;
				counter_note = last_note_index;
			}
			else{
				last_note_index = i;
				last_chord_index = j;//stevenwilson = j; I need to know the last index in the chord array
				getChordDuration();
				makeNoteDur();
				//s_m++; -----------> s_m is the index of the duration array and differs from j
				//last_chord_index = s_m;
				createFirstSpeciesCtp();
				counter_second = chord_i*2;
				console.log("harm_i = " + counter_second);
			}
		}
		
		function onMIDISuccess(midiAccess) {
			console.log(midiAccess);
		    inputs = midiAccess.inputs;
		    outputs = midiAccess.outputs;
		    
		    for (var input of midiAccess.inputs.values()){
		        input.onmidimessage = getMIDIMessage;
		    }
		}

		function getMIDIMessage(midiMessage) {
			message = midiMessage;
			if (message.data[0] == (143 + Number(melody_channel)) || message.data[0] == (127 + Number(melody_channel))){
				note_array[i] = message.data;
				note_time[i] = message.timeStamp;
				i++;
			} else if (message.data[0] == (143 + Number(chord_channel))  || message.data[0] == (127 + Number(chord_channel)) ){
				chord_array[j] = message.data;
				chord_time[j] = message.timeStamp;
				j++;
			}
		}


		var note_i = 0;
		//var total_duration = 0;

		function makeNoteDur(){
			note_duration = note_duration.concat(Array(note_array.length-counter_note));
			last_note_index = note_array.length;
			while(note_i < note_array.length){
				console.log("NOTES");
				getDurationNotes(note_i, note_array, note_time, min_note_time, note_duration, noteOn, counter_note, counter);
				//getDurationNotes(note_i, note_array, note_time, chord_time, note_duration, noteOn, counter_note, counter_chords);
				note_i++;
				//total_duration = note_duration.reduce(getSum);
				//console.log("Total duration = " + total_duration);
				//console.log("Note_i " + note_i);
				//console.log("last note "+ last_note_index);
			}
		}

		//compute note and chord duration array
		function getDurationNotes(index, array_type, time_type, other_time, duration_type, noteOn_type, last_note, other_last){
			if (index == 0){
				specialduration(0, 0, time_type, other_time, duration_type, noteOn_type);
			}else if (index == last_note){
				console.log("SIAMO IN LAST NOTE");
				specialduration(index, other_last, time_type, other_time, duration_type, noteOn_type); //LAST_NOTE
			} else { // if index is not the last
				duration_type[index] = time_type[index] - time_type[index-1];
				noteOn_type[index] = (array_type[index][0] < array_type[index-1][0]);
			}
		}

		function specialduration(index, other_index, time_type, other_time, duration_type, noteOn_type){
			if(time_type[index]>other_time[other_index]){ 
				//if the time of (for example) the note is bigger of the one of the chord then the duration is the difference between the two times plus the arbitrary duration 200ms
				duration_type[index] = time_type[index]-other_time[other_index]+200;
				console.log(duration_type[index] + " duration " + time_type[index]+ " <- first time, second time -> " + other_time[other_index]);
			} else { //otherwise the duration is the arbitrary one
				duration_type[index] = 200; 
				console.log(duration_type[index] + " duration " + time_type[index]+ " <- first time, second time -> " + other_time[other_index]);
			}
			noteOn_type[index] = false;
		}


		//creates two arrays, one containing the minimum note for each chord, one containing its timing information
		var n = 0;
		var m = 1;
		var min_note;
		var min_note_index = 0;
		var min_note_array = new Array; //array che contiene i dati delle note minime di ogni accordo EX SHAIMAESTRO
		var min_note_time = new Array;  //array che contiene le informazioni temporali di ogni minima nota EX AVISHAICOHEN
		var s_m = 0;

		function getMinNote(){
			//min_note = chord_array[0][1]; //[COUNTER][1]?
			min_note = chord_array[counter][1];
			while (m<chord_array.length){
				if (chord_array[m][0] == chord_array[m-1][0]){
					if (Math.min(min_note, chord_array[m][1]) == chord_array[m][1]){
						min_note = chord_array[m][1];
						min_note_index = m; 
					}
					m++;
				} else {
					min_note_array[s_m] = chord_array[min_note_index];
					min_note_time[s_m] = chord_time[min_note_index];
					s_m++;
					m++;
					min_note = chord_array[m-1][1];
					min_note_index = m-1;
				} 
			}
			min_note_array[s_m] = chord_array[min_note_index];
			min_note_time[s_m] = chord_time[min_note_index];
		}

		//creates first species ctp notes and saves them in ctp_vector
		//their duration is chord_duration
		var ctp_vector = new Array;
		var ctp_index = 0;
		var ctpOn = new Array;

		function createFirstSpeciesCtp(){
			while (ctp_index<min_note_array.length){
				ctp_vector[ctp_index] = min_note_array[ctp_index][1] + cons_notes[Math.floor(Math.random() * cons_notes.length)];
				ctpOn[ctp_index] = chordOn[ctp_index];
				ctp_index++; 
			}
			return ctp_vector;
		}

		//second species ctp notes
		var harmOn = new Array;
		var dur_harm = new Array;
		var harm_i;
		var harm_notes = new Array;
		var cons_notes = [4,7,9,12]; 
		var diss_notes = [1,2,3,4,5,6,8,9,10,11];
		//var dur_harm_longer = new Array;
		var chord_i;

		function getChordDuration(){
			getMinNote();
			dur_harm = dur_harm.concat(Array((min_note_array.length-counter)*2));
			for (chord_i = counter; chord_i<min_note_array.length; chord_i++){
				//getDurationNotes(index, array_type, time_type, other_time, duration_type, noteOn_type, last_note, other_last)
				console.log("CHORDS");
				getDurationNotes(chord_i, min_note_array, min_note_time, note_time, chord_duration, chordOn, last_chord_index, last_note_index); // added index for last note index and time note
				harm_i = chord_i * 2;
				dur_harm = dur_harm.fill(chord_duration[chord_i]/2,harm_i,harm_i+2);
				harm_notes[harm_i] = min_note_array[chord_i][1] + cons_notes[Math.floor(Math.random() * cons_notes.length)];
				harmOn[harm_i] = chordOn[chord_i];
				harm_notes[harm_i+1] = min_note_array[chord_i][1] + diss_notes[Math.floor(Math.random() * diss_notes.length)];
				harmOn[harm_i+1] = chordOn[chord_i];
			}

			console.log(dur_harm);
			console.log(harm_notes);
			console.log(harmOn);
		}


		function changeColour(){
			if (harmony){
				if (k == note_duration.length && g == chord_duration.length){
					document.activeElement.classList.toggle("clicked_button");
				} else {
					console.log("Wait");
				}
			} else{
				document.activeElement.classList.toggle("clicked_button");
			}
		}

		//play button functionalities:
		//plays the main melody
		document.querySelectorAll("#play_button").forEach(togglePlay);
		
		function togglePlay(item){
			item.onclick = startPlayingMelodyOnly;
		}
		
		var k = 0;

		function startPlayingMelodyOnly(){
			k = counter_note;
			harmony = false;
			changeColour();
			startPlaying();
		}
		
		function startPlaying(){

			if (k<note_array.length){
				//Melody notes
				midi_freq = note_array[k][1];
				keyb_freq = min_keyb_freq*Math.pow(2,(midi_freq - min_midi_freq)**1/12);

/*
				if (k == counter){
					setTimeout(startPlaying,note_duration[k]/1000);
					console.log("k = 0 --> " + note_duration[k]/1000);
					//k++;
				}
*/
				if(noteOn[k]){
					playMelody(keyb_freq);
					console.log(midi_freq + " = " + keyb_freq + " durata " + note_duration[k] + " ON");
				} else{
					console.log(midi_freq + " = " + keyb_freq + " durata " + note_duration[k] + " OFF");
				}
				setTimeout(startPlaying, note_duration[k]);
				k++;
			}else {
				changeColour();
				//harmony = true;
			}
		}


		//harm button functionalities:
		//plays together the minima notes and the first ctp notes
		document.querySelectorAll("#harm_button").forEach(toggleHarm);
			
		function toggleHarm(item){
			item.onclick = startPlayingChordsOnly;
		}

		function startPlayingChordsOnly(){
			harmony = false;
			changeColour();
			startPlayingChords();
		}


		//plays together the chords harmonized with ctp rules
		var midi_chord_freq;
		var keyb_chord_freq;
		var g = 0;
		function startPlayingChords(){
			if (g<min_note_array.length){
				//Min chord Notes	
				midi_chord_freq = min_note_array[g][1];
				keyb_chord_freq = min_keyb_freq*Math.pow(2,(midi_chord_freq - min_midi_freq)**1/12);
				//Ctp Notes
				midi_first_ctp = ctp_vector[g];
				keyb_first_ctp = min_keyb_freq*Math.pow(2,(midi_first_ctp - min_midi_freq)**1/12);
				if (chordOn[g]){
					startOscillators(keyb_chord_freq,keyb_first_ctp);
				} else {
					console.log("keyb_chord_freq = " + keyb_chord_freq + " chord_duration = " + chord_duration[g] + " OFF"+ " g= " +g);
					console.log("keyb_ctp_freq = " + keyb_first_ctp + " chord_duration = " + chord_duration[g] + " OFF"+ " g= " +g);
				}
				setTimeout(startPlayingChords,chord_duration[g]);
				g++;
			} else {
				changeColour();
			} 
		}

		function getSum(total,num){
			return total+num;
		}

		document.querySelectorAll("#play_all").forEach(toggleHarmony);
		
		function toggleHarmony(item){
			item.onclick = startPlayingHarmony;
		}

		var volume_slider_3 = document.getElementById("volumeControl_3");
		document.querySelectorAll("#volumeControl_3").forEach(toggleVolumeHarmony);

		var output_3 = document.getElementById("span3");
		output_3.innerHTML = volume_slider_3.value;

		function toggleVolumeHarmony(item){
			item.oninput = changeVolumeHarmony;
		}

		function changeVolumeHarmony(event) {
			output_3.innerHTML = volume_slider_3.value;
			constantNode.offset.value = output_3.innerHTML;
			//constantNode.offset.value = constantNode.offset.value.toFixed(2);
			console.log("gain value = " + constantNode.offset.value);
		}

		function startPlayingHarmony(){
				
				k = counter_note;
				g = counter;
				harmony = true;
				startPlaying();
				startPlayingChords();
		}

	
		var context; 
		var oscNode1;
		var oscNode2;
		var oscNode3;
		var constantNode;
		var gainNode1;
		var gainNode2;
		var gainNode3;
		var analyser_min;
		var analyser_ctp
		var bufferLength_min;
		var bufferLength_ctp;
		var dataArray_min;
		var dataArray_ctp;

		var volume_slider_2 = document.getElementById("volumeControl_2");
		document.querySelectorAll("#volumeControl_2").forEach(toggleVolumeChords);

		var output_2 = document.getElementById("span2");
		output_2.innerHTML = volume_slider_2.value;

		function toggleVolumeChords(item){
			item.oninput = changeVolumeChords;
		}

		function changeVolumeChords(event) {
			output_2.innerHTML = volume_slider_2.value;
			constantNode.offset.value = output_2.innerHTML;
			//constantNode.offset.value = constantNode.offset.value.toFixed(2);
			console.log("gain value = " + constantNode.offset.value);
		}

		function startOscillators(freq1,freq2) {

			
			console.log("start");
			context = new AudioContext();

			gainNode3 = context.createGain();
			gainNode3.gain.value = 0.5;

			gainNode1 = context.createGain();
			gainNode1.gain.value = gainNode3.gain.value;
			 
			gainNode2 = context.createGain();
			gainNode2.gain.value = gainNode3.gain.value;

			constantNode = context.createConstantSource();
			constantNode.connect(gainNode1.gain);
			constantNode.connect(gainNode2.gain);
			constantNode.start();
			console.log("constantNode Started");

			gainNode1.connect(context.destination);
			gainNode2.connect(context.destination);
			gainNode3.connect(context.destination);

		  	oscNode1 = context.createOscillator();
		  	oscNode1.frequency.value = freq1;
		  	oscNode1.type = "sine";
			oscNode1.connect(gainNode1);

			oscNode2 = context.createOscillator();
			oscNode2.frequency.value = freq2;
			oscNode2.type = "sine";
			oscNode2.connect(gainNode2);

			oscNode3 = context.createOscillator();
			oscNode3.frequency.value = 0;
			oscNode3.type = "sine";
			oscNode3.connect(gainNode3);

			analyser_min = context.createAnalyser();
		    analyser_min.fftSize = 2048;
		    bufferLength_min = analyser_min.frequencyBinCount;
			dataArray_min = new Uint8Array(bufferLength_min);
			oscNode1.connect(analyser_min);

			analyser_ctp = context.createAnalyser();
		    analyser_ctp.fftSize = 2048;
		    bufferLength_ctp = analyser_ctp.frequencyBinCount;
			dataArray_ctp = new Uint8Array(bufferLength_ctp);
			oscNode2.connect(analyser_ctp);

			oscNode1.start();
			oscNode2.start();
			oscNode3.start();

			current_dur = chord_duration[g]/4000;

			gainNode1.gain.linearRampToValueAtTime(0.3,current_dur); 
  			gainNode1.gain.linearRampToValueAtTime(0,current_dur*4);

  			gainNode2.gain.linearRampToValueAtTime(0.3,current_dur); 
			gainNode2.gain.linearRampToValueAtTime(0,current_dur*4);
	
			console.log("oscillator started");
			console.log("keyb_chord_freq = " + keyb_chord_freq + " chord_duration = " + chord_duration[g] + " ON"+ " g= " +g);
			console.log("keyb_ctp_freq = " + keyb_first_ctp + " chord_duration = " + chord_duration[g] + " ON"+ " g= " +g);

			drawMinNoteSamplesTime();
			drawCtpSamplesTime();

			oscNode1.stop(chord_duration[g]/1000);
			oscNode2.stop(chord_duration[g]/1000);
			oscNode3.stop(chord_duration[g]/1000);
			console.log("oscillator stopped");
		}


		var c;
		var osc;
		var analyser;
		var bufferLength;
		var dataArray;
		var gainNode;

		var volume_slider_1 = document.getElementById("volumeControl_1");
		document.querySelectorAll("#volumeControl_1").forEach(toggleVolumeMelody);

		var output_1 = document.getElementById("span1");
		output_1.innerHTML = volume_slider_1.value;

		function toggleVolumeMelody(item){
			item.oninput = changeVolumeMelody;
		}

		function changeVolumeMelody(event) {
			output_1.innerHTML = volume_slider_1.value;
			gainNode.gain.value = output_1.innerHTML;
			console.log("g.gain.value = " + gainNode.gain.value);
		}

		function playMelody(freq){
			
			c = new AudioContext();

		    osc = c.createOscillator();

		    gainNode = c.createGain();
		    gainNode.gain.value = 0.5;
		    gainNode.connect(c.destination);
		    
		    analyser = c.createAnalyser();
		    analyser.fftSize = 2048;
		    bufferLength = analyser.frequencyBinCount;
			dataArray = new Uint8Array(bufferLength);
			osc.connect(analyser);
			
			osc.connect(gainNode);
		    osc.frequency.value = freq;

		    current_dur = note_duration[k]/4000;

		    osc.start();

		    //gainNode.gain.linearRampToValueAtTime(1,current_dur); 
		   	//gainNode.gain.linearRampToValueAtTime(0,current_dur*4); 
		    
		    drawMelodySamplesTime();
		    
		    osc.stop(note_duration[k]/1000);
		    
		}

		var volume_slider_4 = document.getElementById("volumeControl_4");
		document.querySelectorAll("#volumeControl_4").forEach(toggleVolumeCtp);

		var output_4 = document.getElementById("span4");
		output_4.innerHTML = volume_slider_4.value;

		function toggleVolumeCtp(item){
			item.oninput = changeVolumeCtp;
		}

		function changeVolumeCtp(event) {
			output_4.innerHTML = volume_slider_4.value;
			constantNode.offset.value = output_4.innerHTML;
			//constantNode.offset.value = constantNode.offset.value.toFixed(2);
			console.log("gain value = " + constantNode.offset.value);
		}

		document.querySelectorAll("#second_ctp").forEach(toggle_Second_ctp);
		
		function toggle_Second_ctp(item){
			item.onclick = startPlayingSecondCtp;
		}


		var p = 0;
		function startPlayingCtp(){

			console.log("HERE");
			if (p<harm_notes.length){
				//Melody notes
				midi_freq_second = harm_notes[p];
				keyb_freq_second = min_keyb_freq*Math.pow(2,(midi_freq_second - min_midi_freq)**1/12);

				if(harmOn[p]){ // POSSIAMO PARTIRE DA ZERO A QUESTO PUNTO
					playSecondCtp(keyb_freq_second);
					console.log("midi_freq_second = " + keyb_freq_second + " harm_duration = " + dur_harm[p] + " ON"+ " p= " +p);
				} else{
					//console.log(midi_freq_second + " = " + keyb_freq_second + " durata " + dur_harm[p] + " OFF");
					console.log("midi_freq_second = " + keyb_freq_second + " harm_duration = " + dur_harm[p] + " OFF"+ " p= " +p);
				}
				setTimeout(startPlayingCtp, dur_harm[p]);
				p++;
			} else {
				changeColour();
			}
		}

		function startPlayingSecondCtp(){
				
				g = counter;
				p = counter_second;
				startPlayingCtp();
				startPlayingChords();
		}


		var context_second;
		var osc_second;
		var analyser_second;
		var bufferLength_second;
		var dataArray_second;
		var gainSecond;

		function playSecondCtp(freq){
			context_second = new AudioContext();
			osc_second = context_second.createOscillator();
			gainSecond = context_second.createGain();
			gainSecond.gain.value = 0;
			gainSecond.connect(context_second.destination);
			analyser_second = context_second.createAnalyser();
			analyser_second.fftSize = 2048;
			bufferLength_second = analyser_second.frequencyBinCount;
			dataArray_second = new Uint8Array(bufferLength_second);
			osc_second.connect(analyser_second);
			osc_second.connect(gainSecond);
			osc_second.frequency.value = freq;
			current_dur = dur_harm[p]/4000;
			osc_second.start();
			gainSecond.gain.linearRampToValueAtTime(1,current_dur); 
		   	gainSecond.gain.linearRampToValueAtTime(0,current_dur*4); 
			//drawCtpSamplesFreq();
			drawCtpSamplesTime();
			osc_second.stop(dur_harm[p]/1000);
		}


		//time domain visualization of the selected item
		var time_canvas = document.querySelector("#time_canvas");
		var ctx_time = time_canvas.getContext("2d");


		function drawMelodySamplesTime(){
		 	analyser.getByteTimeDomainData(dataArray);
			ctx_time.clearRect(0,0,time_canvas.width, time_canvas.height);
			ctx_time.beginPath();
			for(var i=0; i<time_canvas.width;i++) {
				ctx_time.lineTo(i,dataArray[i]);
			}
			ctx_time.stroke();
			requestAnimationFrame(drawMelodySamplesTime);
		}

		function drawMinNoteSamplesTime(){
			analyser_min.getByteTimeDomainData(dataArray_min);
			ctx_time.clearRect(0,0,time_canvas.width, time_canvas.height);
			ctx_time.beginPath();
			for(var i=0; i<time_canvas.width;i++) {
				ctx_time.lineTo(i,dataArray_min[i]);
			}
			ctx_time.stroke();
			requestAnimationFrame(drawMinNoteSamplesTime);
		}

		function drawCtpSamplesTime(){
			analyser_ctp.getByteTimeDomainData(dataArray_ctp);
			ctx_time.clearRect(0,0,time_canvas.width, time_canvas.height);
			ctx_time.beginPath();
			for(var i=0; i<time_canvas.width;i++) {
				ctx_time.lineTo(i,dataArray_ctp[i]);
			}
			ctx_time.stroke();
			requestAnimationFrame(drawCtpSamplesTime);
		}

	</script>
</body>
</html>


